<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>R과 금융데이터 (1) - 데이터 불러오기 및 관련 function 연습 | Rock &#39;n&#39; Roh</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/note/">Notes</a></li>
      
      <li><a href="/data/">Data</a></li>
      
      <li><a href="/teaching/">Teaching &amp; 과외</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="http://medium.com/@corr.roh">Medium</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">R과 금융데이터 (1) - 데이터 불러오기 및 관련 function 연습</span></h1>
<h2 class="author">Roh</h2>
<h2 class="date">2020/10/27</h2>
</div>

<main>


<div id="TOC">
<ul>
<li><a href="#패키지-준비하기">패키지 준비하기</a></li>
<li><a href="#데이터-불러오기">데이터 불러오기</a></li>
<li><a href="#csv파일-불러오기">csv파일 불러오기</a></li>
<li><a href="#엑셀-파일-불러오기">엑셀 파일 불러오기</a></li>
</ul>
</div>

<p><strong><strong>Note</strong>: 이 페이지는 Reproducible Finance with R 책을 (과하게) 참고 하였습니다. 다른 Reference 는 밑에 적어 두겠습니다.</strong></p>
<div id="패키지-준비하기" class="section level4">
<h4>패키지 준비하기</h4>
</div>
<div id="데이터-불러오기" class="section level4">
<h4>데이터 불러오기</h4>
<p>아래의 티커를 이용해서 야후 파이낸스로 부터 데이터를 받아옵니다.</p>
<pre class="r"><code>library(purrr)
symbols = c(&#39;SPY&#39;,&#39;EFA&#39;,&#39;IJS&#39;,&#39;EEM&#39;,&#39;AGG&#39;)
prices = 
  getSymbols(symbols,
                    src = &#39;yahoo&#39;,
                    from = &#39;2012-12-31&#39;,
                    to = &#39;2017-12-31&#39;,
                    auto.assign = TRUE,
                    warnings = FALSE) %&gt;%
  map(~Ad((get(.)))) %&gt;% # get adjusted price from each of our individual price series
  reduce(merge) %&gt;% # looks for the date index shared by our objects and uses that index to align the data
  &#39;colnames&lt;-&#39;(symbols) # rename the columns according to the symbols object</code></pre>
<pre><code>## &#39;getSymbols&#39; currently uses auto.assign=TRUE by default, but will
## use auto.assign=FALSE in 0.5-0. You will still be able to use
## &#39;loadSymbols&#39; to automatically load data. getOption(&quot;getSymbols.env&quot;)
## and getOption(&quot;getSymbols.auto.assign&quot;) will still be checked for
## alternate defaults.
## 
## This message is shown once per session and may be disabled by setting 
## options(&quot;getSymbols.warning4.0&quot;=FALSE). See ?getSymbols for details.</code></pre>
<pre class="r"><code>head(prices)</code></pre>
<pre><code>##                 SPY      EFA      IJS      EEM      AGG
## 2012-12-31 122.3169 45.52038 35.92746 37.72139 91.67272
## 2013-01-02 125.4519 46.22488 36.91325 38.46137 91.56543
## 2013-01-03 125.1685 45.77657 36.86440 38.18919 91.33436
## 2013-01-04 125.7181 46.00873 37.15303 38.26574 91.43340
## 2013-01-07 125.3746 45.80859 36.93544 37.97656 91.38387
## 2013-01-08 125.0139 45.55241 36.79335 37.63634 91.46641</code></pre>
<p><strong>map</strong> function
- apply a function to each element of a list or atomic vector
- map() always returns a list</p>
<pre class="r"><code>1:3 %&gt;% map(function(x) rnorm(5, mean=x, sd=1))
## [[1]]
## [1]  1.94410025  1.29697968  0.38557938  1.50636497 -0.01828401
## 
## [[2]]
## [1] 2.9712302 0.4140463 1.9085497 2.7775885 1.4744522
## 
## [[3]]
## [1] 3.622653 3.305619 4.891942 1.535714 3.119022
1:3 %&gt;% map(~ .x**2)
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] 9</code></pre>
<p><strong>Usage of Reduce() and merge()</strong>
- <code>Reduce()</code> takes a function <code>f</code> of two arguments and a list or vector <code>x</code> which is to be ‘reduced’ using <code>f</code>. The function is first called on the first two components of x, then with the result of that as the first argument and the third component of x as the second argument, then again with the result of the second step as first argument and the fourth component of x as the second argument etc. The process is continued until all elements of x have been processed.</p>
<pre class="r"><code>cumsum(1:5)</code></pre>
<pre><code>## [1]  1  3  6 10 15</code></pre>
<pre class="r"><code>Reduce(x=1:5, f=&quot;+&quot;)</code></pre>
<pre><code>## [1] 15</code></pre>
<pre class="r"><code>Reduce(x=1:5, f=&quot;+&quot;, accumulate = TRUE)</code></pre>
<pre><code>## [1]  1  3  6 10 15</code></pre>
<ul>
<li><p>Joining multiple data frames with the same ids but different other columns. While there is a ready-made function <code>join_all()</code> for this in the <code>plyr</code> package, we will see shortly how to solve this task using <code>Reduce()</code> using the <code>merge()</code> function from base <code>R</code>.</p></li>
<li><p>Sums of matrix powers</p></li>
</ul>
<pre class="r"><code>P = rbind(c(0.9,0.1),c(1,0))
library(expm)</code></pre>
<pre><code>## Loading required package: Matrix</code></pre>
<pre><code>## 
## Attaching package: &#39;Matrix&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:tidyr&#39;:
## 
##     expand, pack, unpack</code></pre>
<pre><code>## 
## Attaching package: &#39;expm&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:Matrix&#39;:
## 
##     expm</code></pre>
<pre class="r"><code>P_power = lapply(0:10, function(k) P %^% k)
head(P_power)</code></pre>
<pre><code>## [[1]]
##      [,1] [,2]
## [1,]    1    0
## [2,]    0    1
## 
## [[2]]
##      [,1] [,2]
## [1,]  0.9  0.1
## [2,]  1.0  0.0
## 
## [[3]]
##      [,1] [,2]
## [1,] 0.91 0.09
## [2,] 0.90 0.10
## 
## [[4]]
##       [,1]  [,2]
## [1,] 0.909 0.091
## [2,] 0.910 0.090
## 
## [[5]]
##        [,1]   [,2]
## [1,] 0.9091 0.0909
## [2,] 0.9090 0.0910
## 
## [[6]]
##         [,1]    [,2]
## [1,] 0.90909 0.09091
## [2,] 0.90910 0.09090</code></pre>
<pre class="r"><code>Reduce(P_power, f=&quot;+&quot;)</code></pre>
<pre><code>##           [,1]      [,2]
## [1,] 10.082645 0.9173554
## [2,]  9.173554 1.8264463</code></pre>
<ul>
<li>Simulating a trajectory of a Markov Chain without a loop</li>
</ul>
<pre class="r"><code>P &lt;- matrix(c(0, 0.1, 0.9, 0.2, 0.5, 0.3, 0, 0.5, 0.5), ncol = 3, byrow = T);
P</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]  0.0  0.1  0.9
## [2,]  0.2  0.5  0.3
## [3,]  0.0  0.5  0.5</code></pre>
<pre class="r"><code>x_0 &lt;- 2
newstate &lt;- function(oldstate,u) {
  which.min(u&gt;cumsum(P[oldstate,]))
}
x_1 = newstate(x_0, runif(1)); x_1</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>x_2 = newstate(x_1, runif(1)); x_2</code></pre>
<pre><code>## [1] 3</code></pre>
<p>We can continue to do this without looping by using the function <code>Reduce</code>.
We just have to provide a vector that contains the starting state as first component and the K uniform random numbers needed to generate the following states. We also set <code>accumulate=TRUE</code>, because we want the whole trajectory and not only the state at time K.</p>
<pre class="r"><code>set.seed(1)
K = 500
mc_without_loop = Reduce(newstate, c(x_0,runif(K)),accumulate = TRUE)
mc_without_loop</code></pre>
<pre><code>##   [1] 2 2 2 2 3 2 3 3 3 3 2 2 1 3 2 3 2 3 3 2 3 3 2 2 1 3 2 1 3 3 2 2 2 2 1 3 3
##  [38] 3 2 3 2 3 3 3 3 3 3 2 2 3 3 2 3 2 2 1 2 2 2 2 2 3 2 2 2 2 2 2 3 2 3 2 3 2
##  [75] 2 2 3 3 2 3 3 2 3 2 2 3 2 3 2 2 1 3 2 2 3 3 3 2 2 3 3 3 2 2 3 3 2 1 3 3 3
## [112] 3 3 2 2 1 2 3 2 2 2 3 2 2 1 3 2 2 2 2 2 2 1 2 2 3 3 3 3 3 3 3 3 2 2 3 2 1
## [149] 3 2 3 3 3 2 2 2 1 3 2 2 2 2 3 2 3 3 2 1 3 3 2 2 3 3 2 2 3 3 3 3 3 2 1 3 3
## [186] 3 2 3 3 3 3 3 2 1 3 2 2 1 3 2 3 2 2 2 2 1 3 3 2 2 3 3 2 3 3 3 2 2 3 3 2 2
## [223] 1 3 3 3 3 2 1 3 3 2 1 3 3 2 2 2 2 2 2 2 2 3 2 2 2 2 1 3 3 3 3 2 2 2 1 3 2
## [260] 2 3 3 2 2 3 3 2 1 3 3 2 1 3 2 1 3 2 2 1 3 3 2 2 3 2 1 3 2 1 3 2 2 1 3 2 2
## [297] 2 1 3 2 3 3 2 2 2 2 3 2 3 2 2 1 3 3 3 2 2 1 3 3 3 3 2 2 3 3 3 3 3 2 3 3 2
## [334] 2 3 2 2 2 1 3 3 3 2 2 2 2 2 2 1 3 3 2 1 3 2 3 2 3 2 3 2 1 3 3 2 2 3 2 3 3
## [371] 2 2 2 3 2 2 2 2 3 2 2 2 2 2 3 2 2 3 3 2 3 2 1 3 3 2 2 2 2 2 1 3 2 3 3 3 3
## [408] 2 3 2 3 3 2 3 3 3 2 2 2 2 3 2 2 2 1 3 2 1 3 3 3 3 2 2 2 1 3 3 2 2 3 2 2 2
## [445] 2 2 2 2 3 2 1 3 2 2 1 2 2 2 3 3 2 1 3 2 2 2 3 3 2 2 2 2 3 3 2 1 3 3 2 2 2
## [482] 3 2 3 3 3 3 2 1 3 2 1 3 2 1 3 2 2 2 3 2</code></pre>
<pre class="r"><code># Distribution of states:
table(mc_without_loop)/length(mc_without_loop)</code></pre>
<pre><code>## mc_without_loop
##          1          2          3 
## 0.09580838 0.48303393 0.42115768</code></pre>
</div>
<div id="csv파일-불러오기" class="section level4">
<h4>csv파일 불러오기</h4>
<p>The function <code>tk_xts(date_var = date)</code> converts the data frame to an xts object.</p>
<pre class="r"><code>prices = 
  read_csv(&#39;Reproducible Finance.csv&#39;,
           col_types = 
             cols(date = col_date(format=&#39;%Y-%m-%d&#39;))) %&gt;%
  tk_xts(date_var = date)</code></pre>
<pre><code>## Warning: Non-numeric columns being dropped: date</code></pre>
</div>
<div id="엑셀-파일-불러오기" class="section level4">
<h4>엑셀 파일 불러오기</h4>
<pre class="r"><code>prices = 
  read_excel(&#39;Reproducible Finance.xlsx&#39;,
             col_types = c(&#39;text&#39;,&#39;numeric&#39;,&#39;numeric&#39;,&#39;numeric&#39;,&#39;numeric&#39;,&#39;numeric&#39;)) %&gt;%
  mutate(date = ymd(date)) %&gt;%
  tk_xts(date_var = date)</code></pre>
<pre><code>## Warning: Non-numeric columns being dropped: date</code></pre>
</div>

</main>

  <footer>
  <script src="//yihui.org/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.org/js/center-img.js"></script>

  
  <hr/>
  © <a href="/">Roh</a> 2020 | <a href="https://github.com/rockandroh">Github</a> | <a href="https://medium.com/@corr.roh">Medium</a>
  
  </footer>
  </body>
</html>

