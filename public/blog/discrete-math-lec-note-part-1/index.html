<!DOCTYPE html>
<html lang="en-us">
  <head>
    <link rel="stylesheet" href="/css/bootstrap.css" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>이산수학 전반부 정리 | Rock &#39;n&#39; Roh</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />

    
    
      <link rel="stylesheet" href="/css/prism-vs.css" />

    
    

  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/blog/">Blog</a></li>
      
      <li><a href="/projects/">Projects</a></li>
      
      <li><a href="/teaching/">Teaching &amp; 과외</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="https://corr-roh.medium.com/">Medium</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">이산수학 전반부 정리</span></h1>
<h2 class="author">Roh</h2>
<h2 class="date">2020/10/17</h2>
</div>

<main>


<div id="TOC">
<ul>
<li><a href="#이산수학-렉쳐노트-정리">이산수학 렉쳐노트 정리</a><ul>
<li><a href="#주차-명제와-논리">1주차: 명제와 논리</a></li>
<li><a href="#주차-증명의-정의와-종류">2주차: 증명의 정의와 종류</a></li>
<li><a href="#주차-집합의-개념과-종류-연산과-법칙">3주차: 집합의 개념과 종류 &amp; 연산과 법칙</a></li>
<li><a href="#주차-수의-표현-및-연산">4주차: 수의 표현 및 연산</a></li>
<li><a href="#주차-보수와-행렬">5주차 : 보수와 행렬</a></li>
<li><a href="#주차-행렬">6주차: 행렬</a></li>
</ul></li>
</ul>
</div>

<div id="이산수학-렉쳐노트-정리" class="section level1">
<h1>이산수학 렉쳐노트 정리</h1>
<p>수업 교안을 간단하게 개념만 적는거라 내용이 많이 부실합니다. 자세한 내용은 나중에 추가하도록 하겠습니다.</p>
<div id="주차-명제와-논리" class="section level2">
<h2>1주차: 명제와 논리</h2>
<div id="명제와-논리연산자" class="section level4">
<h4>명제와 논리연산자</h4>
<p><strong>명제</strong></p>
<ul>
<li>명제(Proposition): 참이나 거짓으로 구분할 수 있는 문장이나 수식</li>
<li>진리값(Truth Value): 참이나 거짓을 가리키는 값(i.e., T or F, 0 or 1)
<ul>
<li>In R, Zero is considered <code>FALSE</code> and non-zero numbers are taken as <code>TRUE</code></li>
</ul></li>
</ul>
<p><strong>논리 연산자</strong></p>
<ul>
<li>부정(Negation): Not
<ul>
<li>명제 p가 명제이면, “p가 아니다” 또한 마찬가지로 명제이다</li>
<li>즉, 명제의 부정또한 명제이다.</li>
<li><span class="math inline">\(\neg\)</span> p</li>
</ul></li>
<li>논리곱(Conjunction): And
<ul>
<li>문장 p,q가 명제일때, p,q의 진리값이 모두 참일때’만’ 참이되고, 그렇지 않을때는 거짓이 되는 명제</li>
<li><span class="math inline">\(p \land q\)</span></li>
</ul></li>
<li>논리합(Disjunction): OR
<ul>
<li>문장 p,q가 명제일때, p,q의 진릿값이 모두 거짓일때’만’ 거짓이 되고, 그렇지 않으면 참이되는 명제</li>
<li><span class="math inline">\(p \lor q\)</span></li>
</ul></li>
<li>배타적 논리합(Exclusive OR): XOR
<ul>
<li>문장 p,q가 명제일때, p,q의 진릿값 중 하나’만’ 참일때 참이되고, 그렇지 않으면 거짓이 되는 명제</li>
<li><span class="math inline">\(p \oplus q\)</span></li>
</ul></li>
</ul>
<p><strong>합성명제(Compound Proposition)</strong></p>
<ul>
<li>우선순위
<ol style="list-style-type: decimal">
<li><span class="math inline">\(\neg\)</span></li>
<li><span class="math inline">\(\land\)</span>, <span class="math inline">\(\lor\)</span></li>
<li><span class="math inline">\(\oplus\)</span></li>
</ol></li>
<li>항진명제(Tautology): 합성명제를 구성하는 명제의 진릿값에 상관없이 합성명제의 진릿값이 항상 참인 명제 (<span class="math inline">\(p\lor \neg p\)</span>)</li>
<li>모순명제(Contradiction): 합성명제를 구성하는 명제들의 진릿값에 상관없이 합성명제의 진릿값이 항상 거짓인 명제 (<span class="math inline">\(p\land \neg p\)</span>)</li>
<li>사건명제(Contingency): 항진명제도, 모순명제도 아닌 명제</li>
</ul>
<p>Below is R example.</p>
<pre class="r"><code>p = c(TRUE, TRUE, FALSE, FALSE)
q = c(TRUE, FALSE, TRUE, FALSE)
isTRUE(FALSE)
## [1] FALSE

!p # NOT
## [1] FALSE FALSE  TRUE  TRUE

# Element-wise logical AND (&amp;) 
p&amp;q 
## [1]  TRUE FALSE FALSE FALSE
p&amp;!q 
## [1] FALSE  TRUE FALSE FALSE

# Element-wise logical OR (|)
p|q
## [1]  TRUE  TRUE  TRUE FALSE

# Element-wise exclusive OR
xor(p,q)
## [1] FALSE  TRUE  TRUE FALSE

# Logical AND
# Examines only the first element of the operands resulting into a single length logical vector
!p&amp;&amp;!q 
## [1] FALSE
q&amp;&amp;q 
## [1] TRUE
p&amp;&amp;p
## [1] TRUE

# Logical OR
# Examines only the first element of the operands resulting into a single length logical vector
p||q
## [1] TRUE
!p||!q
## [1] FALSE

xor(!(p&amp;q),(!p|q))
## [1]  TRUE  TRUE FALSE FALSE</code></pre>
</div>
<div id="합성함축조건쌍방조건-명제" class="section level4">
<h4>합성/함축조건/쌍방조건 명제</h4>
<p><strong>함축(Implication)에 관한 진리표</strong></p>
<table>
<thead>
<tr class="header">
<th align="center">p</th>
<th align="center">q</th>
<th align="center">p <span class="math inline">\(\rightarrow\)</span> q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">T</td>
<td align="center">T</td>
<td align="center">T</td>
</tr>
<tr class="even">
<td align="center">T</td>
<td align="center">F</td>
<td align="center">F</td>
</tr>
<tr class="odd">
<td align="center">F</td>
<td align="center">T</td>
<td align="center">T</td>
</tr>
<tr class="even">
<td align="center">F</td>
<td align="center">F</td>
<td align="center">T</td>
</tr>
</tbody>
</table>
<p>Ex) 부산이 대한민국의 수도면, 10은 양수다의 진릿값은 참이다. 왜냐하면 결과 명제가 원인 명제와 상관없이 항상 참이기 때문이다.</p>
<p><strong>쌍방조건명제(Biconditional)에 관한 진리표</strong></p>
<table>
<thead>
<tr class="header">
<th align="center">p</th>
<th align="center">q</th>
<th align="center">p <span class="math inline">\(\leftrightarrow\)</span> q</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">T</td>
<td align="center">T</td>
<td align="center">T</td>
</tr>
<tr class="even">
<td align="center">T</td>
<td align="center">F</td>
<td align="center">F</td>
</tr>
<tr class="odd">
<td align="center">F</td>
<td align="center">T</td>
<td align="center">F</td>
</tr>
<tr class="even">
<td align="center">F</td>
<td align="center">F</td>
<td align="center">T</td>
</tr>
</tbody>
</table>
</div>
<div id="역이대우와-논리적-동치" class="section level4">
<h4>역/이/대우와 논리적 동치</h4>
<ul>
<li>p <span class="math inline">\(\rightarrow\)</span> q
<ul>
<li>역(converse): q <span class="math inline">\(\rightarrow\)</span> p</li>
<li>이(inverse) : <span class="math inline">\(\neg\)</span>p <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(\neg\)</span>q</li>
<li>대우(contraposition): <span class="math inline">\(\neg\)</span>q <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(\neg\)</span>p</li>
</ul></li>
</ul>
</div>
<div id="논리적-동치" class="section level4">
<h4>논리적 동치</h4>
<ul>
<li>합성명제 p와 q의 진릿값이 같은 경우</li>
<li><span class="math inline">\(p \equiv q\)</span></li>
<li><span class="math inline">\(p \rightarrow q \equiv \neg p \lor q\)</span></li>
</ul>
<p>명제함수 (Propositional Function) P(x)
- 명제함수 <span class="math inline">\(P(x) = x^2 - 3x =0\)</span> 일때, P(1)은 거짓이고 P(3)은 참이다.</p>
<p>한정기호
- 전체한정자(Universal Quantifier): <span class="math inline">\(\forall\)</span>
- 존재한정자(Existential Quantifier): <span class="math inline">\(\exists\)</span></p>
<p><strong>논리적 추론법칙</strong></p>
<p>예제: 다음과 같이 전제로 주어진 명제가 항상 참이라고 할때, 열쇠가 어디에 있는지 찾아라.</p>
<ol style="list-style-type: lower-alpha">
<li>열쇠가 서랍에 있었다면, 출근할 때 열쇠를 보았다.</li>
<li>내가 아침을 먹었다면, 열쇠는 서랍에 있다.</li>
<li>나는 샤워를 했거나 아침을 먹었다.</li>
<li>내가 샤워를 했다면, 열쇠는 가방 속에 있다.</li>
<li>내가 출근할 때, 나는 열쇠를 보지 못했다.</li>
</ol>
<p><span class="math inline">\(\therefore\)</span> 열쇠는 가방 속에 있다.</p>
</div>
</div>
<div id="주차-증명의-정의와-종류" class="section level2">
<h2>2주차: 증명의 정의와 종류</h2>
<ul>
<li>공리
<ul>
<li>별도의 증명 없이 참으로 이용되는 명제</li>
</ul></li>
<li>정의
<ul>
<li>논의의 대상을 보편화하기 위해 사용하는 용어 또는 기호의 의미를 확실하게 규정한 문장이나 식</li>
</ul></li>
<li>정리
<ul>
<li>공리와 정의를 통해 참으로 확인된 명제</li>
</ul></li>
<li>증명
<ul>
<li>하나의 명제가 참임을 확인하는 과정</li>
<li>증명법: 직접증명법/간접증명법/대우증명법/모순증명법/반례증명법/존재증명법/수학적 귀납법</li>
</ul></li>
</ul>
</div>
<div id="주차-집합의-개념과-종류-연산과-법칙" class="section level2">
<h2>3주차: 집합의 개념과 종류 &amp; 연산과 법칙</h2>
<ul>
<li>직합의 표기형식
<ul>
<li>원소 나열법: <span class="math inline">\(S={1,2,3,4,5}\)</span></li>
<li>조건제시법: <span class="math inline">\(S = \{ s|0\le s\le 5, s\in\mathbb{N} \}\)</span></li>
</ul></li>
<li><span class="math inline">\(x \in X\)</span>, <span class="math inline">\(x \notin X\)</span></li>
<li>기수 (Cardinality): <span class="math inline">\(|A|\)</span>
<ul>
<li>집합 A 가 포함하는 원소의 수</li>
</ul></li>
<li>유한집합 / 무한집합</li>
<li>합집합 / 교집합 / 서로소(Disjoint) / 차집합(Difference) / 대칭차집합 (Symmetric Difference) / 여집합 (Complement) / 곱집합 (Cartesian Product) / 멱집합 (Power Set) /</li>
<li>집합의 대수법칙
<ul>
<li>항등법칙, 지배법칙, 멱등(Idempotent)법칙, 교환법칙, 결합법칙, 분배법칙, 보법칙, 드모르간의 법칙, 흡수법칙</li>
</ul></li>
</ul>
</div>
<div id="주차-수의-표현-및-연산" class="section level2">
<h2>4주차: 수의 표현 및 연산</h2>
<ul>
<li><span class="math inline">\(\mathbb{N},\mathbb{Q},\mathbb{R},\mathbb{C}\)</span></li>
<li>수체계: 10진수, 2진수, 8진수, 16진수 그리고 서로간의 변환</li>
</ul>
<pre class="r"><code>#install.packages(&#39;DescTools&#39;)
library(DescTools)
DecToBin(c(21,12))
## [1] &quot;10101&quot; &quot;1100&quot;
BinToDec(c(10101,1100))
## [1] 21 12
DecToHex(c(21,12))
## [1] &quot;15&quot; &quot;0c&quot;
HexToDec(c(15,&#39;0c&#39;))
## [1] 21 12
DecToOct(c(21,12))
## [1] 25 14
OctToDec(c(25,14))
## [1] 21 12</code></pre>
<pre class="r"><code>temp = c(&#39;11100101&#39;)
DecToOct(BinToDec(temp))</code></pre>
<pre><code>## [1] 345</code></pre>
</div>
<div id="주차-보수와-행렬" class="section level2">
<h2>5주차 : 보수와 행렬</h2>
<ul>
<li>보수: 보충해 주는 수
<ul>
<li>1의 보수: 어떤 수 n 과의 합이 1이 되는 수</li>
<li>2의 보수: 어떤 수 n 과의 합이 2가 되는 수</li>
</ul></li>
<li>부호화 - 절대치 표현: 부호와 데이터의 절댓값을 그대로 표현하는 방법</li>
<li>부호화 - 1의 보수표현
<ul>
<li>음수의 표현에만 적용된다.</li>
<li>음수에 대한 부호화: 절대치 표현에서 부호 비트는 그대로 사용</li>
<li>음수에 대한 부호화: 절대치 표현에서 절대치 비트에 대해 0은 1로, 1은 0으로 바꿔 표현</li>
</ul></li>
<li>부호화 - 2의 보수 표현
<ul>
<li>음수 표현에만 적용된다.</li>
<li>음수에 대한 부호화: 절대치 표현에서 부호 비트는 그대로 사용</li>
<li>음수에 대한 부호화: 절대치 표현에서 절대치 비트에 대한 1의 보수에 1을 더함</li>
</ul></li>
</ul>
<dl>
<dt>Ex1) 10진수 +53과 -53을 8비트의 부호화-절대치 표현으로 나타내는 경우</dt>
<dd><p>53을 2진수로 변화하면 1101012이다. 8비트의 가장 왼쪽에 있는 비트는 최상위 비트므로 그 자리에 부호를 의미하는 0(양수) 또는 1(음수)가 입려된다. 나머지 자리에는 절댓값이 오른쪽부터 채워진다.</p>
</dd>
</dl>
<p>-<span class="math inline">\(+53_{10} = 00110101\)</span>
-<span class="math inline">\(-53_{10} = 10110101\)</span></p>
<dl>
<dt>Ex2) 10진수 +53과 -53을 8비트 1의 보수 표현으로 나타내라.</dt>
<dd><p>보수는 음수 표현에만 사용하므로 +53에대한 1의 보수표현은 부호화-절대치표현과 같다.</p>
</dd>
</dl>
<p><span class="math inline">\(-53_{10}\)</span> 은 음수이므로 1의 보수표현으로 바꿀 수 있다. <span class="math inline">\(-53_{10}\)</span>의 부호화-절대치 표현은 -<span class="math inline">\(-53_{10} = 10110101\)</span> 이므로, 부호 비트를 제외한 절대치 표현에 대해 0은 1로, 1은 0으로 바꾸면 된다.</p>
<p><span class="math inline">\(\therefore -53_{10}=11001010\)</span></p>
<dl>
<dt>Ex3) 10진수 +53과 -53을 8비트 2의 보수 표현으로 나타내라.</dt>
<dd><p>보수는 음수 표현에만 사용하므로 +53에대한 2의 보수표현은 부호화-절대치표현과 같다.</p>
</dd>
</dl>
<p><span class="math inline">\(-53_{10}\)</span> 은 음수이므로 2의 보수표현으로 바꿀 수 있다. <span class="math inline">\(-53_{10}\)</span>의 부호화-절대치 표현은 -<span class="math inline">\(-53_{10} = 10110101\)</span> 이고, 1의 보수표현은 11001010이므로 여기서 1을 더하면 11001011이다.</p>
<p><strong>보수 표현을 사용하는 이유</strong>
- 부호화-절대치 표현의 한계
- 연산 결과가 정확하지 않다.
- 0의 표현이 두 가지
- 양수0: 0000 / 음수0: 1000
- 1의 보수 표현의 한계
- 계산 결과는 정확하나, 여전히 0의 표현이 두가지
- 양수0: 0000 / 음수0: 1111
- 1의 보수 10진수 변환 (2가지)
1. <span class="math inline">\(-(2^{n-1}-1)\)</span> + 절대치 비트의 10진수 표현
2. 주어진 1의 보수를 다시 한번 1의 보수로 변환 후, 그에 대해 10진수 표현</p>
<p>예시) 8비트 표현을 사용하는 컴퓨터에서 1의 보수 11001011을 10진수로 변환하라.</p>
<p>11001011에서 최상위 비트 1은 부호 비트고 나머지는 절대치 비트다.</p>
<p>$11001011 = -(2^{8-1}-1) + 12^6 + 02^5 + 02^4 + 12^3 + 02^2 + 12^1 + 12^0 $</p>
<p><span class="math inline">\(-127+(64+0+0+8+0+2+1)=-127+75=-52\)</span></p>
<p><strong>보수연산시 주의사항</strong>
- 초과가 발생하는경우
- 1의보수: 다시 한번더 연산
- 2의보수: 무시</p>
<p><strong>행렬</strong>
- 부울행렬(Bollean Matrix, Zero-One Matrix)
- 행렬식</p>
<pre class="r"><code>A = matrix(c(3,2,1,-1),2,2)
B = rbind(c(3,-1,-2),c(-4,2,1),c(1,4,-3))
det(A)</code></pre>
<pre><code>## [1] -5</code></pre>
<pre class="r"><code>det(B)</code></pre>
<pre><code>## [1] 17</code></pre>
<ul>
<li>소행렬 (Minor MAtrix): <span class="math inline">\(M_{rs}\)</span>
<ul>
<li>n차 정사각 행렬에서 r번째 행과 s번째 열을 제거해서 얻은 <span class="math inline">\((n-1)\times(n-1)\)</span> 행렬</li>
</ul></li>
<li>여인수 (Cofactor) <span class="math inline">\(A_{ij}\)</span>
<ul>
<li>n차 정사각행렬 <span class="math inline">\(A=[a_{ij}]\)</span> 에서 원소 <span class="math inline">\(a_{ij}\)</span> 에 관련된 수 와 그 수에 대한 행렬 <span class="math inline">\(A_{ij}=(-1)^{i+j} det(M_{ij})\)</span></li>
</ul></li>
</ul>
</div>
<div id="주차-행렬" class="section level2">
<h2>6주차: 행렬</h2>
<ul>
<li>역행렬</li>
</ul>
<pre class="r"><code>C = rbind(c(1,2,3),c(2,-1,1),c(3,0,-1))
C</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    2   -1    1
## [3,]    3    0   -1</code></pre>
<pre class="r"><code>solve(C)</code></pre>
<pre><code>##      [,1] [,2]  [,3]
## [1,] 0.05  0.1  0.25
## [2,] 0.25 -0.5  0.25
## [3,] 0.15  0.3 -0.25</code></pre>
</div>
</div>

</main>


<br></br>
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/blog/bootstrapping-and-its-application-in-r/">Bootstrapping and its Implementation in R</a></span>
  <span class="nav-next"><a href="/blog/data-structure-summary/">자료구조 전반부 키워드 정리</a> &rarr;</span>
</nav>
<br></br>


  <footer>

  
    <script src="//yihui.name/js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>


  




<script>
var divs = document.querySelectorAll('pre');
var languages = {'r': true, 'python': true, 'html': true, 'bash': true}

for (var i = 0; i < divs.length; i++) {
  var classes = divs[i].className.split(/\s+/);

  for (var j = 0; j < classes.length; j++) {
    if (languages[classes[j]]) {
      divs[i].classList.add("language-" + classes[j]);
    }
  }
}
</script>

<script src="/js/prism.js"></script>

<script>
  Prism.languages.r = Prism.languages.extend('r', {
    'keyword': /\b(?:if|else|repeat|while|function|for|in|next|break|NULL|NA|NA_integer_|NA_real_|NA_complex_|NA_character_|library)\b/
  })
</script>



  

  
  <hr/>
  © <a href="/">Roh</a> 2020 | <a href="https://github.com/rockandroh">Github</a> | <a href="https://corr-roh.medium.com/">Medium</a>
  
  
    
    
    
    
      
    
    
  
  </footer>
  </body>
</html>

